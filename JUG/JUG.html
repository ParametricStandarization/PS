<!DOCTYPE html>
<html>
    <head>
        <script src="../lib/OpenPlus.js"></script>
        <script src="../lib/verb.js"></script>
        <script src="../lib/three.min.js"></script>
        <script src="../lib/verbToThreeConversion.js"></script>
        <script src="../lib/OrbitControls.js"></script>
        <script src="../lib/threeBasic.js"></script>
        <script src="../lib/STLLoader.js"></script>
        <script src="../lib/ObjectControls.js"></script>
        
        <script src="../lib/FileSaver.js"></script>
        <script src="../lib/meshToSTL.js"></script>

        <style type="text/css">
            body { 
                margin: 0; 
                background: white;

                text-align: center;
            }

            .centerDivTop {

                position: absolute;
                left: 50%;
                top: 5%;

                /*text-align: left;*/
            }
            
            .centerDivBottom {

                position: absolute;
                left: 50%;
                bottom: 5%;

                /*text-align: left;*/
            }

            .titleContainer {
                font-family:"Tahoma", "Arial", "Verdana";
                font-weight: bold;

                position: relative;
                left: -50%;

                z-index: -1;
            }
            
            .exportContainer {
                font-family:"Tahoma", "Arial", "Verdana";
                font-weight: bold;

                position: relative;
                left: -50%;
            }

            #objectContainer {
            }

            .mainTitle {
                font-size: 1000%;
            }

            .product {
                font-size: 300%;
            }

            .part {
                font-size: 150%;

                /*text-align: left;*/
            }
            
            .button {
                font-size: 150%;

                text-align: left;
            }
            
            .button:active {
                text-decoration: underline;
            }


        </style>
    </head>
    <body>

        <div id="objectContainer">
        </div>

        <div class="centerDivTop">
            <div class="titleContainer">
                <span class="mainTitle">PS</span><span class="mainTitle">/</span><span class="product">JUG</span><br>
                <span class="part">SINNERLIG</span><span class="part"> + </span><span class="part">BRASS</span>
            </div>
        </div>

        <div class="centerDivBottom">
            <div class="exportContainer">
                <a class="button">PRINT</a><span class="part"> / </span><a class="button" onclick="exportJug()">EXPORT</a><br>
            </div>
        </div>

        <script>

            threeSetup(true);

            Jug = function () {

                this.materialFront = new THREE.MeshPhongMaterial({
                    color: 0xffb6c1
                    , side: THREE.FrontSide
                    , wireframe: false
                            //        , transparent: true, opacity: 1
                    , transparent: true, opacity: 0.8
                            //, shading : THREE.FlatShading
                    , shading: THREE.SmoothShading
                });

                this.materialBack = new THREE.MeshPhongMaterial({
                    color: 0xffb6c1
                    , side: THREE.BackSide
                    , wireframe: false
                            //        , transparent: true, opacity: 1
                    , transparent: true, opacity: 0.8
                            //, shading : THREE.FlatShading
                    , shading: THREE.SmoothShading
                });

                //set variables for the Jug
                this.rimWidth = 1;
                this.vesselDiameter = 21;
                this.handleDiameter = 4;
                this.handleLength = 5;

                this.tensionerGap = 0.5;
                this.screwDiameter = 0.3;
                this.screwOffset = 1;

                this.minRimCover = 2;

                this.offset = 1;
                this.margin = 0.3;

                this.spoutMargin = 0.3;

                //changeable variables for the Jug
                this.spoutHeight = 5;
                this.maxInnerSpoutHeight;
                this.innerSpoutHeight;
                this.spoutLength = 4;
                
                this.fullInnerHeight;

                //set standard values that change by others
                this.SetArcAngles();

                this.tensionerHeight = this.screwDiameter + (this.screwOffset * 2);
                this.rimHeight = 7;
                this.connectorHeight = this.rimHeight + this.tensionerHeight;

                //saved vars of outerSpout
                this.outerSpoutVars = {};


                var d1 = Date.now();
                
                //need to make an inner and an outer spout variable

                //build jug
                this.BuildVesselTensioner();
                this.BuildOuterSpout();
                this.BuildInnerSpout();
                this.BuildOuterVessel();
                this.BuildInnerVessel();
                this.BuildVesselHandle();
                this.BuildHandleTensioner();
                this.BuildHandleBridge();

                scene.add(this.outerSpout);
                scene.add(this.innerSpout);
                scene.add(this.outerVessel);
                scene.add(this.innerVesselMesh);
                scene.add(this.vesselToHandleMesh);
                scene.add(this.handleTensionerMesh);
                scene.add(this.bottomTensioner);
                scene.add(this.handleMesh);

                var outerRadius = (this.vesselDiameter / 2) + this.margin + this.offset;
                var spoutTip = [outerRadius + this.spoutLength, 0, this.connectorHeight];
                this.spoutLengthHandler = addIntersectObject(
                        spoutTip,
                        this,
                        "setSpoutLength",
                        {origin: [outerRadius, 0, this.connectorHeight],
                            direction: [10, 0, 0]});

                var spoutConPt = [outerRadius, 0, this.connectorHeight - this.spoutHeight];
                this.spoutHeightHandler = addIntersectObject(
                        spoutConPt,
                        this,
                        "setSpoutHeight",
                        {origin: [outerRadius, 0, this.margin],
                            direction: [0, 0, this.connectorHeight - this.margin]});

                var conHeightPt = [0, 0, this.connectorHeight];
                this.conHeightHandler = addIntersectObject(
                        conHeightPt,
                        this,
                        "setConnectorHeight",
                        {origin: [0, 0, this.rimHeight + this.tensionerHeight],
                            direction: [0, 0, 20]});

                var outerHandleRadius = (this.handleDiameter / 2) + this.margin + this.offset;
                var conHandlePt = [-(outerRadius + outerHandleRadius + this.handleLength), 0, this.connectorHeight];
                this.handleHandler = addIntersectObject(
                        conHandlePt,
                        this,
                        "setHandleLength",
                        {origin: [-(outerRadius + this.tensionerHeight + outerHandleRadius), 0, this.connectorHeight],
                            direction: [-20, 0, 0]});


                var d2 = Date.now();
                console.log("built complete in ", (d2 - d1), " ms ");
            };

            Jug.prototype.SetArcAngles = function () {

                var outerRadiusV = (this.vesselDiameter / 2) + this.margin;
                var outerRadiusH = (this.handleDiameter / 2) + this.margin;

                var smallestRadius = outerRadiusV < outerRadiusH;

                var radiusS = smallestRadius ? outerRadiusV : outerRadiusH;
                var radiusL = smallestRadius ? outerRadiusH : outerRadiusV;

                var angleS = Math.PI * 0.1;
                var y = radiusS * Math.sin(angleS);

                var angleL = Math.asin(y / radiusL);

                this.vesselTensionerAngle = smallestRadius ? angleS : angleL;
                this.handleTensionerAngle = smallestRadius ? Math.PI - angleL : Math.PI - angleS;

                this.vesselTopAngleEnd = Math.asin(y / (outerRadiusV + this.offset));
                this.vesselTopAngleStart = Math.asin((y + this.offset) / (outerRadiusV + this.offset));
            };

            Jug.prototype.BuildVesselTensioner = function () {

                var d1 = Date.now();

                var tensionerHeight = this.tensionerHeight;

                var center = [0, 0, 0];
                var xAxis = [-1, 0, 0];
                var yAxis = [0, 1, 0];

                var innerRadius = (this.vesselDiameter / 2) + this.margin;
                var outerRadius = (this.vesselDiameter / 2) + this.offset + this.margin;
                var minAngle = this.vesselTensionerAngle;

                var meshesFront = [];
                var meshesBack = [];

                //create bottom horizontal plane

                //start with making inner Arc
                var innerArcA = new verb.geom.Arc(center, xAxis, yAxis, innerRadius,
                        minAngle, Math.PI / 2);
                var innerArcB = new verb.geom.Arc(center, xAxis, yAxis, innerRadius,
                        Math.PI / 2, Math.PI);

                var innerArcStart = innerArcA.point(0);

                //need to know what startPoints these are
                var innerStartPoint = [-(tensionerHeight + outerRadius), innerArcStart[1], 0];

                var innerTensionerLineA = new verb.geom.Line(innerStartPoint, innerArcStart);

                //here I want to offset the previous curves in the xy plane.
                //but this is actually a rather complex algorithm that is not yet written
                //if I could only write haxe... but rather I'll fumble around it

                //do it the matimatical way
                var offsetY = innerStartPoint[1] + this.offset;

                minAngle = Math.asin(offsetY / outerRadius);

                var xAxis = [1, 0, 0];

                var outerArcB = new verb.geom.Arc(center, xAxis, yAxis, outerRadius,
                        0, Math.PI * 0.5);
                var outerArcC = new verb.geom.Arc(center, xAxis, yAxis, outerRadius,
                        Math.PI * 0.5, Math.PI - minAngle);

                var outerArcEnd = outerArcC.point(1);

                //move the points in y direction for the offset of the lines.
                var outerEndPoint = [innerStartPoint[0], offsetY, 0];

                var outerTensionerLineA = new verb.geom.Line(outerArcEnd, outerEndPoint);

                //now to write the bridging lines
                var bridgeLineB = new verb.geom.Line(outerEndPoint, innerStartPoint);
                var bridgeLineD = new verb.geom.Line(innerArcB.point(0), outerArcC.point(0));
                var halfWayCloseCrv = new verb.geom.Line(innerArcB.point(1), outerArcB.point(0));

                var geomPlanarA = OpenPlus.PlanarSrf([innerArcA, innerArcB, halfWayCloseCrv
                            , outerArcB, outerArcC
                            , outerTensionerLineA, bridgeLineB, innerTensionerLineA
                ])[0];

                meshesBack.push(geomPlanarA);

                //de extrusies maken van de edges
                var curvesToExtrudeA = [innerArcA, bridgeLineB, outerArcC];

                var loopLength = curvesToExtrudeA.length;
                for (var i = 0; i < loopLength; i++) {
                    var curve = curvesToExtrudeA[i];
                    var srf = new verb.geom.ExtrudedSurface(curve, [0, 0, tensionerHeight]);

                    var srfGeom = srf.toThreeGeometry();

                    meshesBack.push(srfGeom);
                }

                var srf = new verb.geom.ExtrudedSurface(bridgeLineD,
                        [0, 0, this.tensionerGap]);

                var geom = srf.toThreeGeometry();
                geom.translate(0,0,tensionerHeight);

                meshesFront.push(geom);

                //de bovenste horizontale plaat maken
                var geomB = OpenPlus.PlanarSrf([outerArcC
                            , outerTensionerLineA, bridgeLineB, innerTensionerLineA
                            , innerArcA, bridgeLineD
                ])[0];
                
                geomB.translate(0,0,tensionerHeight);

                meshesFront.push(geomB);

                //only create the last two pieces
                //the flaps with screw holes

                //first create the offsets
                //need to do this planar, and then rotate them
                //will do this on one side and then mirror
                var p1 = innerTensionerLineA.point(0),
                    p2 = innerTensionerLineA.point(1),
                    p3 = verb.core.Vec.add(p2, [0, 0, tensionerHeight]),
                    p4 = verb.core.Vec.add(p1, [0, 0, tensionerHeight]);

                var innerTensionerSide = OpenPlus.PolyLine([p1, p2, p3, p4, p1]);

                var screwRadius = this.screwDiameter / 2;

                var circleCenter = [p4[0] + this.screwOffset + screwRadius,
                    p4[1], tensionerHeight/2];
                var screwHole = new verb.geom.Circle(circleCenter, xAxis, [0,0,1], screwRadius);

                var geomPlanarB = OpenPlus.PlanarSrf([ innerTensionerSide,
                    screwHole.reverse() ])[0];

                meshesBack.push(geomPlanarB);

                p1 = outerTensionerLineA.point(0),
                p2 = outerTensionerLineA.point(1),
                p3 = verb.core.Vec.add(p2, [0, 0, tensionerHeight]),
                p4 = verb.core.Vec.add(p1, [0, 0, tensionerHeight]);

                var outerTensionerSide = OpenPlus.PolyLine([p1, p2, p3, p4, p1]);

                circleCenter = [p3[0] + this.screwOffset + screwRadius,
                    p3[1], tensionerHeight/2];
                screwHole = new verb.geom.Circle(circleCenter, xAxis, [0,0,1], screwRadius);

                var geomPlanarC = OpenPlus.PlanarSrf([ outerTensionerSide,
                    screwHole ])[0];

                meshesBack.push(geomPlanarC);

                //create extrusion of screwHole
                center = [circleCenter[0], p1[1], tensionerHeight / 2];
                xAxis = [1, 0, 0];
                yAxis = [0, 0, 1];
                screwHole = new verb.geom.Circle(center, xAxis, yAxis, screwRadius);

                var screwExtrusion = new verb.geom.ExtrudedSurface(screwHole, [0, -this.offset, 0]);
                var screwHoleGeom = screwExtrusion.toThreeGeometry();

                meshesFront.push(screwHoleGeom);

                //merge meshes and mirror them to finish tensioner
                this.bottomTensioner = OpenPlus.mirrorCombineMesh(
                        meshesFront, meshesBack, this.materialFront, this.materialBack);

                var d2 = Date.now();
                //console.log("built tensioner in ", (d2 - d1), " ms ");
            };

            Jug.prototype.BuildOuterSpout = function () {
                var d1 = Date.now();

                var meshesFront = [];
                var meshesBack = [];

                var offset = this.offset;
                var innerRadius = (this.vesselDiameter / 2) - this.rimWidth;
                var outerRadius = (this.vesselDiameter / 2) + this.margin + offset;
                var connectorHeight = this.connectorHeight;
                var spoutHeight = this.spoutHeight;
                var spoutLength = this.spoutLength;

                //tip of the spout to create teh spoutSide
                var outerIntLineEnd = [0, outerRadius, connectorHeight];
                var outerSpoutTipPt = [outerRadius + spoutLength, 0, connectorHeight];
                var outerSpoutConPt = [outerRadius, 0, connectorHeight - spoutHeight];

                var center = [0, 0, connectorHeight];
                var xAxis = [1, 0, 0];
                var yAxis = [0, 1, 0];

                var intCircLinePt = OpenPlus.CircleLineIntersect(outerSpoutTipPt, outerIntLineEnd
                        , {center: [0, 0], radius: outerRadius})[1];
                intCircLinePt[2] = connectorHeight;

                var angle = OpenPlus.AnglePtOnCircle(intCircLinePt, outerRadius);

                var outerSpoutConIntArc = new verb.geom.Arc(
                        center, xAxis, yAxis, outerRadius, 0, angle);

                var outerSpoutCrv = new verb.geom.Line(outerSpoutTipPt, intCircLinePt);

                var vecA = verb.core.Vec.sub(intCircLinePt, outerSpoutTipPt);
                var vecB = verb.core.Vec.sub(outerSpoutConPt, outerSpoutTipPt);

                var planeOrigin = outerSpoutTipPt;
                var planeNormal = verb.core.Vec.cross(vecA, vecB);

                var segmentPtA = outerSpoutConIntArc.point(0.5);
                var segmentPtB = [segmentPtA[0], segmentPtA[1], 0];

                var intersectPtLoc = verb.eval.Intersect.segmentAndPlane(
                        segmentPtA, segmentPtB, planeOrigin, planeNormal);

                var segment = new verb.geom.Line(segmentPtA, segmentPtB);

                var intersectPt = segment.point(intersectPtLoc.p);

                //creation of the outerSpoutConRidge
                var outerSpoutConRidge = verb.geom.NurbsCurve.byKnotsControlPointsWeights(
                        2,
                        [0, 0, 0, 1, 1, 1],
                        [outerSpoutConPt, intersectPt, intCircLinePt],
                        [1, 1, 1]);

                var outerSpoutSide = OpenPlus.PlanarSrf([
                    outerSpoutCrv,
                    outerSpoutConRidge,
                    new verb.geom.Line(outerSpoutTipPt, outerSpoutConPt)
                ])[0];

                var loftUVLength = outerSpoutConRidge.controlPoints().length;

                var that = this;

                //points to represent a new bottom curve of the jug
                
                 var transMat = OpenPlus.MatrixTranslation([0,0,- spoutHeight]);
                
                outerSpoutConIntArc = outerSpoutConIntArc.transform(transMat);
                
                
//                outerSpoutConIntArc._data.controlPoints.forEach(function (obj) {
//                    obj[2] = that.connectorHeight - that.spoutHeight;
//                });
                
                //creation of part of CylinderEdge
                var outerCylEdge = verb.geom.NurbsSurface.byLoftingCurves(
                        [outerSpoutConRidge, outerSpoutConIntArc], loftUVLength);
                
                outerCylEdge._data.controlPoints[0][0] = outerSpoutConRidge._data.controlPoints[0];
                outerCylEdge._data.controlPoints[0][1] = outerSpoutConIntArc._data.controlPoints[0];

                meshesFront.push(outerSpoutSide);
                meshesFront.push(outerCylEdge.toThreeGeometry());

                //extract a closing arc to create a closing surface
                var outerClosingArc = new verb.geom.Arc(
                        center, xAxis, yAxis, outerRadius, angle, Math.PI * 0.5);

                var outerExtrVec = [0, 0, -this.spoutHeight];

                var outerClosingExtr = new verb.geom.ExtrudedSurface(outerClosingArc, outerExtrVec);
                var outerClosingExtrGeom = outerClosingExtr.toThreeGeometry();

                meshesFront.push(outerClosingExtrGeom);

                //now to create the offset to close the upper layer

                //translation is dependent on a hourglass function
                //  |\
                //  | \         lengthA   widthA
                //  |  \        ------- = ------
                //  |__ \_      lengthB   widthB
                //       \|

                var lengthB = outerSpoutCrv.length();
                
                var widthA = this.offset;
                var widthB = intCircLinePt[1];

                var lengthA = lengthB * (widthA / widthB);

                //translate the points 
                var innerSpoutTipPt = verb.core.Vec.add(outerSpoutTipPt, [-lengthA, 0, 0]);
                var offsetOuterIntLineEnd = verb.core.Vec.add(outerIntLineEnd, [-lengthA, 0, 0]);

                var outerTopInt = OpenPlus.CircleLineIntersect(innerSpoutTipPt, offsetOuterIntLineEnd
                        , {center: [0, 0], radius: innerRadius});
                var innerTopIntCircLinePt = outerTopInt[outerTopInt.length - 1];
                innerTopIntCircLinePt[2] = connectorHeight;

                var topAngle = OpenPlus.AnglePtOnCircle(innerTopIntCircLinePt, innerRadius);

                //create the closingArc
                var innerClosingArc = new verb.geom.Arc(
                        center, xAxis, yAxis, innerRadius, topAngle, Math.PI * 0.5);

                //the create the line that represents the innerSpoutEdge
                var innerSpoutCrv = new verb.geom.Line(innerSpoutTipPt, innerTopIntCircLinePt);

                //now I can close the topLayer
                var topBridgeLineHalf = new verb.geom.Line(innerClosingArc.point(1), outerIntLineEnd);
                var topBridgeLineSpout = new verb.geom.Line(innerSpoutTipPt, outerSpoutTipPt);

                var topPlanarSrfGeom = OpenPlus.PlanarSrf([topBridgeLineHalf
                            , topBridgeLineSpout, innerClosingArc, outerClosingArc
                            , innerSpoutCrv, outerSpoutCrv
                ])[0];

                meshesFront.push(topPlanarSrfGeom);

                this.outerSpoutVars.innerSpoutTipPt = innerSpoutTipPt;
                this.outerSpoutVars.topAngle = topAngle;
                this.outerSpoutVars.innerClosingArc = innerClosingArc;
                this.outerSpoutVars.innerTopIntCircLinePt = innerTopIntCircLinePt;
                this.outerSpoutVars.innerSpoutCrv = innerSpoutCrv;

                //merge meshes and mirror them to finish tensioner
                this.outerSpout = OpenPlus.mirrorCombineMesh(
                        meshesFront, meshesBack, this.materialFront, this.materialBack);

                var d2 = Date.now();
                //console.log("built spout in ", (d2 - d1), " ms ");
            };
            
            Jug.prototype.BuildInnerSpout = function () {
                
                var meshesFront = [];
                var meshesBack = [];
                
                var offset = this.offset;
                var innerRadius = (this.vesselDiameter / 2) - this.rimWidth;
                var outerRadius = (this.vesselDiameter / 2) + this.margin + offset;
                var connectorHeight = this.connectorHeight;
                var spoutHeight = this.spoutHeight;
                var spoutLength = this.spoutLength;
                var innerConnectorHeight = this.rimHeight + this.spoutMargin;
                
                var outerIntLineEnd = [0, outerRadius, connectorHeight];
                var outerSpoutTipPt = [outerRadius + spoutLength, 0, connectorHeight];
                
                var innerSpoutTipPt = this.outerSpoutVars.innerSpoutTipPt;
                var topAngle = this.outerSpoutVars.topAngle;
                var innerClosingArc = this.outerSpoutVars.innerClosingArc;
                var innerTopIntCircLinePt = this.outerSpoutVars.innerTopIntCircLinePt;
                var innerSpoutCrv = this.outerSpoutVars.innerSpoutCrv;
                
                
                var center = [0, 0, connectorHeight];
                var xAxis = [1, 0, 0];
                var yAxis = [0, 1, 0];
                
                //depending on the z height of the innerRidge we know if we will also need
                //a bottomAngle
                var innerSpoutLength = innerSpoutTipPt[0] - innerRadius;
                var innerSpoutHeight = spoutHeight * (innerSpoutLength / spoutLength);
                
                this.maxInnerSpoutHeight = innerSpoutHeight;
                
                //two versions of creating the innerspout
                var innerSpoutRidge;
                var innerSpoutConIntArc;
                var innerSpoutConPt;

                var aboveConnectorHeight = (connectorHeight - innerSpoutHeight) > innerConnectorHeight;
                this.fullInnerHeight = aboveConnectorHeight;
                
                if (aboveConnectorHeight) {
                    innerSpoutConIntArc = new verb.geom.Arc(
                            center, xAxis, yAxis, innerRadius, 0, topAngle);

                    innerSpoutConPt = [innerRadius, 0, connectorHeight - innerSpoutHeight];

                    innerSpoutRidge = new verb.geom.Line(innerSpoutConPt, innerSpoutTipPt);
                } else {
                    innerSpoutHeight = connectorHeight - innerConnectorHeight;

                    innerSpoutLength = spoutLength * (innerSpoutHeight / spoutHeight);

                    innerSpoutConPt = [innerSpoutTipPt[0] - innerSpoutLength
                                , 0, connectorHeight - innerSpoutHeight];

                    innerSpoutRidge = new verb.geom.Line(innerSpoutConPt, innerSpoutTipPt);

                    var transVec = verb.core.Vec.sub(outerIntLineEnd, outerSpoutTipPt);
                    var transPt = verb.core.Vec.add(innerSpoutConPt, transVec);

                    var innerBottomIntCircLinePt = OpenPlus.CircleLineIntersect(innerSpoutConPt, transPt
                            , {center: [0, 0], radius: innerRadius})[1];
                    innerBottomIntCircLinePt[2] = connectorHeight;

                    var bottomAngle = OpenPlus.AnglePtOnCircle(innerBottomIntCircLinePt, innerRadius);

                    innerSpoutConIntArc = new verb.geom.Arc(center, xAxis, yAxis,
                            innerRadius, bottomAngle, topAngle);

                    //make the last planarCrv here
                    center = [0, 0, innerConnectorHeight];

                    var innerSpoutClosingArc = new verb.geom.Arc(center, xAxis, yAxis,
                            innerRadius, 0, bottomAngle);

                    var spoutPlateCrv = new verb.geom.Line(
                            innerSpoutClosingArc.point(0), innerSpoutRidge.point(0));

                    var spoutPlate = OpenPlus.PlanarSrf([spoutPlateCrv,
                        innerSpoutClosingArc])[0];

                    //add parts to meshes
                    meshesFront.push(spoutPlate);

                    var innerSpoutConPt = innerSpoutConIntArc.point(0);
                    innerSpoutConPt[2] = this.rimHeight + this.margin;
                }
                
                this.innerSpoutHeight = innerSpoutHeight;
                
                //create the innerClosingExtrusion
                var innerExtrVec = [0, 0, -innerSpoutHeight];

                var innerClosingExtr = new verb.geom.ExtrudedSurface(innerClosingArc, innerExtrVec);
                var innerClosingExtrGeom = innerClosingExtr.toThreeGeometry();

                meshesBack.push(innerClosingExtrGeom);
                
                //continue with the  variables to create the innerCylEdge
                var vecA = verb.core.Vec.sub(innerTopIntCircLinePt, innerSpoutTipPt);
                var vecB = verb.core.Vec.sub(innerSpoutConPt, innerSpoutTipPt);

                var planeOrigin = innerSpoutTipPt;
                var planeNormal = verb.core.Vec.cross(vecA, vecB);

                var segmentPtA = innerSpoutConIntArc.point(0.5);
                var segmentPtB = [segmentPtA[0], segmentPtA[1], 0];

                var intersectPtLoc = verb.eval.Intersect.segmentAndPlane(
                        segmentPtA, segmentPtB, planeOrigin, planeNormal);

                var segment = new verb.geom.Line(segmentPtA, segmentPtB);

                var intersectPt = segment.point(intersectPtLoc.p);

                //creation of the innerSpoutConRidge
                var innerSpoutConRidge = verb.geom.NurbsCurve.byKnotsControlPointsWeights(
                        2,
                        [0, 0, 0, 1, 1, 1],
                        [innerSpoutConPt, intersectPt, innerTopIntCircLinePt],
                        [1, 1, 1]);

                var innerSpoutSide = OpenPlus.PlanarSrf([
                    innerSpoutConRidge, innerSpoutCrv, innerSpoutRidge])[0];

                //points to represent a new bottom curve of the jug
                innerSpoutConIntArc._data.controlPoints.forEach(function (obj) {
                    obj[2] = obj[2] - innerSpoutHeight;
                });

                //creation of part of CylinderEdge
                loftUVLength = innerSpoutConRidge.controlPoints().length;

                var innerCylEdge = verb.geom.NurbsSurface.byLoftingCurves(
                        [innerSpoutConRidge, innerSpoutConIntArc], loftUVLength);

                innerCylEdge._data.controlPoints[0][0] = innerSpoutConRidge._data.controlPoints[0];
                innerCylEdge._data.controlPoints[0][1] = innerSpoutConIntArc._data.controlPoints[0];

                //add parts to meshes
                if (aboveConnectorHeight)
                    meshesFront.push(innerSpoutSide);
                else
                    meshesBack.push(innerSpoutSide);
                meshesBack.push(innerCylEdge.toThreeGeometry());
                
                //merge meshes and mirror them to finish tensioner
                this.innerSpout = OpenPlus.mirrorCombineMesh(
                        meshesFront, meshesBack, this.materialFront, this.materialBack);

            };
            
            Jug.prototype.BuildOuterVessel = function () {
                var offset = this.offset;
                var outerRadius = (this.vesselDiameter / 2) + this.margin + offset;
                var connectorHeight = this.connectorHeight;
                var spoutHeight = this.spoutHeight;
                
                var center = [0, 0, 0];
                var xAxis = [1, 0, 0];
                var yAxis = [0, 1, 0];
                
                var outerArc = new verb.geom.Arc(center, xAxis, yAxis, outerRadius,
                    0, Math.PI /2);
                    
                var extrVec = [0,0,connectorHeight - spoutHeight];
                
                var outerArcExtr = new verb.geom.ExtrudedSurface(outerArc, extrVec);
                var outerArcExtrGeom = outerArcExtr.toThreeGeometry();

//                this.outerVessel = new THREE.Mesh(outerArcExtrGeom, this.materialBack);
                //merge meshes and mirror them to finish tensioner
                this.outerVessel = OpenPlus.mirrorCombineMesh(
                        [], [outerArcExtrGeom], this.materialFront, this.materialBack);
            };

            Jug.prototype.BuildInnerVessel = function () {
                var d1 = Date.now();

                var meshesFront = [];
                var meshesBack = [];

                var tensionerGap = this.tensionerGap;
                var tensionerHeight = this.tensionerHeight;
                var extrusionHeight = this.rimHeight - (tensionerGap + tensionerHeight);
                var midConnectionHeight = tensionerHeight + tensionerGap + extrusionHeight;
                var midRadius = (this.vesselDiameter / 2) + this.margin;
                var innerRadius = (this.vesselDiameter / 2) - this.rimWidth;
                var outerRadius = midRadius + this.offset;

                var center = [0, 0, 0];
                var xAxis = [1, 0, 0];
                var yAxis = [0, 1, 0];

                //first make the side of the spout because of change of centerHeight
                var spoutWallMidCurve = new verb.geom.Arc(center, xAxis, yAxis, midRadius,
                        Math.PI * 1.5, Math.PI * 2);

                var spoutWallMidExtr =
                        new verb.geom.ExtrudedSurface(spoutWallMidCurve, [0, 0, this.rimHeight]);

                meshesFront.push(spoutWallMidExtr.toThreeGeometry());

                //change the height of the center for the next part
                center[2] = midConnectionHeight;

                var spoutWallInnerCurve = new verb.geom.Arc(center, xAxis, yAxis, innerRadius,
                        Math.PI * 1.5, Math.PI * 2);

                var spoutWallInnerExtr =
                        new verb.geom.ExtrudedSurface(spoutWallInnerCurve, [0, 0, this.spoutMargin]);

                meshesFront.push(spoutWallInnerExtr.toThreeGeometry());

                //now do the handle side of things
                var midRadiusCurve = new verb.geom.Arc(center, xAxis, yAxis, midRadius,
                        Math.PI / 2, Math.PI);

                //extrusion of inner wall
                var midRadiusExtrude =
                        new verb.geom.ExtrudedSurface(midRadiusCurve, [0, 0, -extrusionHeight]);

                meshesBack.push(midRadiusExtrude.toThreeGeometry());

                //offset of first curve to create first horizontal plane
                var innerRadiusCurve = new verb.geom.Arc(center, xAxis, yAxis, innerRadius,
                        Math.PI / 2, Math.PI);

                //lines that connect the two curves
                var startPoint = innerRadiusCurve.point(0);
                var endPoint = midRadiusCurve.point(0);

                var bridgeLineA = new verb.geom.Line(startPoint, endPoint);

                startPoint = innerRadiusCurve.point(1);
                endPoint = midRadiusCurve.point(1);

                var bridgeLineB = new verb.geom.Line(startPoint, endPoint);

                var middleConnection = OpenPlus.PlanarSrf(
                        [midRadiusCurve, bridgeLineA, innerRadiusCurve, bridgeLineB])[0];

                //need to do this translation because th eplanar recognition from
                //path is not yet working

                meshesBack.push(middleConnection);

                //can rotate this middleConnection for the spout side as well
                var middleConRot = new THREE.Geometry().copy(middleConnection);
                
                var rotMat = OpenPlus.MatrixAxisAngle([0,0,1], Math.PI);
                var rotMatThree = OpenPlus.ToThreeMatrix(rotMat);
                
                middleConRot.applyMatrix(rotMatThree);

                meshesBack.push(middleConRot);

                //extrude the innerCurve
                var innerRadiusExtrude = new verb.geom.ExtrudedSurface
                        (innerRadiusCurve, [0, 0, this.connectorHeight - midConnectionHeight]);

                meshesFront.push(innerRadiusExtrude.toThreeGeometry());

                //create top horizontal plane
                var outerRadiusCurve = new verb.geom.Arc(center, xAxis, yAxis, outerRadius,
                        Math.PI / 2, Math.PI);

                startPoint = innerRadiusCurve.point(0);
                endPoint = outerRadiusCurve.point(0);

                bridgeLineA = new verb.geom.Line(startPoint, endPoint);

                startPoint = innerRadiusCurve.point(1);
                endPoint = outerRadiusCurve.point(1);

                bridgeLineB = new verb.geom.Line(startPoint, endPoint);

                var topLayerGeom = OpenPlus.PlanarSrf(
                        [outerRadiusCurve, bridgeLineA, innerRadiusCurve, bridgeLineB])[0];

                //need to do this translation because th eplanar recognition from
                //path is not yet working
                topLayerGeom.translate(0,0,this.connectorHeight - this.rimHeight);

                meshesFront.push(topLayerGeom);

                //merge meshes and mirror them to finish tensioner
                this.innerVesselMesh = OpenPlus.mirrorCombineMesh(
                        meshesFront, meshesBack, this.materialFront, this.materialBack);

                //time the process
                var d2 = Date.now();
                //console.log("built innerhalf in ", (d2 - d1), " ms ");
            };

            Jug.prototype.BuildVesselHandle = function () {
                var d1 = Date.now();

                var meshesFront = [];
                var meshesBack = [];

                var tensionerGap = this.tensionerGap;
                var tensionerHeight = this.tensionerHeight;
                var bottomConnectionHeight = tensionerHeight + tensionerGap;
                var midRadius = (this.vesselDiameter / 2) + this.margin;
                var outerRadius = midRadius + this.offset;

                var center = [0, 0, bottomConnectionHeight];
                var xAxis = [1, 0, 0];
                var yAxis = [0, 1, 0];

                var innerRadiusCurve = new verb.geom.Arc(center, xAxis, yAxis, midRadius,
                        Math.PI / 2, Math.PI);

                var outerRadiusCurve = new verb.geom.Arc(center, xAxis, yAxis, outerRadius,
                        Math.PI / 2, Math.PI);

                //lines that connect the two curves
                var startPoint = innerRadiusCurve.point(0);
                var endPoint = outerRadiusCurve.point(0);

                var bridgeLineA = new verb.geom.Line(startPoint, endPoint);

                startPoint = innerRadiusCurve.point(1);
                endPoint = outerRadiusCurve.point(1);

                var bridgeLineB = new verb.geom.Line(startPoint, endPoint);

                var middleConnection = OpenPlus.PlanarSrf(
                        [outerRadiusCurve, bridgeLineA, innerRadiusCurve, bridgeLineB])[0];

                meshesBack.push(middleConnection);

                //extrude curve up till vesselHeight - tensionerHeight
                if (this.connectorHeight - tensionerHeight > tensionerHeight + tensionerGap)
                {
                    var extrusionHeight = this.connectorHeight - (tensionerHeight * 2) - tensionerGap;
                    var outerHalf = new verb.geom.ExtrudedSurface(outerRadiusCurve,
                            [0, 0, extrusionHeight]);

                    meshesBack.push(outerHalf.toThreeGeometry());
                }

                var center = [0, 0, this.connectorHeight - tensionerHeight];

                var outerHandleCurve = new verb.geom.Arc(center, xAxis, yAxis, outerRadius,
                        Math.PI / 2, Math.PI - this.vesselTopAngleStart);

                var extrusionHeight = tensionerHeight;
                var outerHalfHandle = new verb.geom.ExtrudedSurface(outerHandleCurve,
                        [0, 0, extrusionHeight]);

                meshesBack.push(outerHalfHandle.toThreeGeometry());

                //merge meshes and mirror them to finish tensioner
                this.vesselToHandleMesh = OpenPlus.mirrorCombineMesh(
                        meshesFront, meshesBack, this.materialFront, this.materialBack);

                //time the process
                var d2 = Date.now();
                //console.log("built vesselHalf in ", (d2 - d1), " ms ");
            };

            Jug.prototype.BuildHandleTensioner = function () {
                var d1 = Date.now();

                var meshesFront = [];
                var meshesBack = [];

                var offset = this.offset;
                var screwOffset = this.screwOffset;
                var tensionerHeight = this.tensionerHeight;
                var connectorHeight = this.connectorHeight;
                var handleHeight = (connectorHeight / 2) > (tensionerHeight * 2) ?
                        connectorHeight / 2 : tensionerHeight * 2;
                var outerRadius = (this.vesselDiameter / 2) + this.margin + offset;
                var innerHandleRadius = (this.handleDiameter / 2) + this.margin;
                var outerHandleRadius = innerHandleRadius + offset;
                var screwRadius = this.screwDiameter / 2;

                var center = [-(outerRadius + this.handleLength + outerHandleRadius), 0,
                    connectorHeight - handleHeight];
                var xAxis = [1, 0, 0];
                var yAxis = [0, 1, 0];
                var zAxis = [0, 0, 1];

                var innerArc = new verb.geom.Arc(center, xAxis, yAxis, innerHandleRadius,
                        (Math.PI) - this.handleTensionerAngle, Math.PI);

                var innerArcStart = innerArc.point(0);
                var innerStartPoint = [center[0] + outerHandleRadius + tensionerHeight,
                    innerArcStart[1], center[2]];

                var innerStartLine = new verb.geom.Line(innerStartPoint, innerArcStart);

                //now I have to manually offset this again.
                var offsetY = innerArcStart[1] + offset;
                var minAngle = Math.asin(offsetY / outerHandleRadius);

                var outerArc = new verb.geom.Arc(center, xAxis, yAxis, outerHandleRadius,
                        minAngle, Math.PI);

                var outerArcStart = outerArc.point(0);
                var outerStartPoint = [innerStartPoint[0], offsetY, innerStartPoint[2]];

                var outerStartLine = new verb.geom.Line(outerStartPoint, outerArcStart);

                var bridgeLineA = new verb.geom.Line(innerStartPoint, outerStartPoint);
                var bridgeLineB = new verb.geom.Line(outerArc.point(1), innerArc.point(1));

                //now create the horizontal planar surface
                var bottomHandleGeom = OpenPlus.PlanarSrf([innerArc, innerStartLine
                            , bridgeLineA, outerStartLine, outerArc, bridgeLineB])[0];

                var topHandleGeom = new THREE.Geometry().copy(bottomHandleGeom);
                topHandleGeom.translate(0,0,handleHeight);

                meshesBack.push(bottomHandleGeom);
                meshesFront.push(topHandleGeom);

                var extrusionVec = [0, 0, handleHeight];

                var innerArcExtr = new verb.geom.ExtrudedSurface(innerArc, extrusionVec);
                var outerArcExtr = new verb.geom.ExtrudedSurface(outerArc, extrusionVec);

                meshesFront.push(innerArcExtr.toThreeGeometry());
                meshesBack.push(outerArcExtr.toThreeGeometry());

                extrusionVec = [0, 0, handleHeight - tensionerHeight];

                var bridgeLineAExtr = new verb.geom.ExtrudedSurface(bridgeLineA, extrusionVec);

                meshesBack.push(bridgeLineAExtr.toThreeGeometry());

                //now to yet again create the screw holes and tension flaps
                var p1 = innerStartLine.point(0),
                        p2 = innerStartLine.point(1),
                        p3 = [p2[0], p2[1], p2[2] + handleHeight],
                        p4 = [p1[0], p1[1], p1[2] + handleHeight];

                var innerTensionerSide = OpenPlus.PolyLine([p1, p2, p3, p4, p1]);

                var circleCenter = [p1[0] - (screwOffset + screwRadius),
                    p1[1], p1[2] + (screwOffset + screwRadius)];
                var screwHole = new verb.geom.Circle(circleCenter, xAxis, zAxis, screwRadius);

                var innerTensionerSideGeom = OpenPlus.PlanarSrf([innerTensionerSide,
                    screwHole])[0];

                //create outerTensionerSide
                var p1 = outerStartLine.point(0),
                        p2 = outerStartLine.point(1),
                        p3 = [p2[0], p2[1], p2[2] + handleHeight],
                        p4 = [p1[0], p1[1], p1[2] + handleHeight];

                var outerTensionerSide = OpenPlus.PolyLine([p1, p2, p3, p4]);

                circleCenter = [p1[0] - (screwOffset + screwRadius),
                    p1[1], p1[2] + (screwOffset + screwRadius)];
                screwHole = new verb.geom.Circle(circleCenter, xAxis, zAxis, screwRadius);

                var outerTensionerSideGeom = OpenPlus.PlanarSrf([outerTensionerSide,
                    screwHole])[0];

                //create extrusion of screwHole
                var screwExtrusion = new verb.geom.ExtrudedSurface(screwHole, [0, -offset, 0]);
                var screwHoleGeom = screwExtrusion.toThreeGeometry();

                meshesFront.push(innerTensionerSideGeom);
                meshesBack.push(outerTensionerSideGeom);
                meshesFront.push(screwHoleGeom);

                this.handleTensionerMesh = OpenPlus.mirrorCombineMesh(
                        meshesFront, meshesBack, this.materialFront, this.materialBack);

                //time the process
                var d2 = Date.now();
                //console.log("built handleTensioner in ", (d2 - d1), " ms ");
            };

            Jug.prototype.BuildHandleBridge = function () {
                var d1 = Date.now();

                var meshesFront = [];
                var meshesBack = [];

                var tensionerGap = this.tensionerGap;
                var handleHeight = this.tensionerHeight;
                var outerRadius = (this.vesselDiameter / 2) + this.margin + this.offset;
                var handleEnd = -(outerRadius + this.handleLength - handleHeight);

                var center = [0, 0, this.connectorHeight];
                var xAxis = [1, 0, 0];
                var yAxis = [0, 1, 0];

                var outerVesselCurve = new verb.geom.Arc(center, xAxis, yAxis, outerRadius,
                        Math.PI - this.vesselTopAngleStart, Math.PI - this.vesselTopAngleEnd);

                var vesselPointStart = outerVesselCurve.point(0);
                var vesselPointEnd = outerVesselCurve.point(1);
                var handlePointStart = [handleEnd, vesselPointEnd[1], this.connectorHeight];
                var handlePointEnd = [handleEnd, vesselPointStart[1], this.connectorHeight];

                var handleSideInnerCurve = new verb.geom.Line(vesselPointEnd, handlePointStart);
                var handleSideOuterCurve = new verb.geom.Line(handlePointEnd, vesselPointStart);
                var outerHandleCurve = new verb.geom.Line(handlePointStart, handlePointEnd);

                var midHandleCurve = new verb.geom.Arc(center, xAxis, yAxis, outerRadius,
                        Math.PI - this.vesselTopAngleEnd, Math.PI);

                //making of extrusions
                var handleHeightVec = [0, 0, -handleHeight];

                var topHandleGeom = OpenPlus.PlanarSrf([outerVesselCurve,
                    handleSideInnerCurve, handleSideOuterCurve, outerHandleCurve])[0];

                var topHandleGeomMirror = new THREE.Geometry().copy(topHandleGeom);
                topHandleGeomMirror.translate(0,0,-handleHeight);

                meshesFront.push(topHandleGeom);
                meshesBack.push(topHandleGeomMirror);

                var outerSide = new verb.geom.ExtrudedSurface(
                        handleSideOuterCurve, handleHeightVec);
                var innerSide = new verb.geom.ExtrudedSurface(
                        handleSideInnerCurve, handleHeightVec);

                meshesBack.push(outerSide.toThreeGeometry());
                meshesBack.push(innerSide.toThreeGeometry());

                var midhandle = new verb.geom.ExtrudedSurface(midHandleCurve,
                        handleHeightVec);

                meshesFront.push(midhandle.toThreeGeometry());

                this.handleMesh = OpenPlus.mirrorCombineMesh(meshesFront,
                        meshesBack, this.materialFront, this.materialBack);

                //time the process
                var d2 = Date.now();
                //console.log("built handleBridge in ", (d2 - d1), " ms ");
            };

            Jug.prototype.Error = function (e) {
                console.log(e);
            };
            
            Jug.prototype.makeSTL = function(){
                
                console.log(this.outerSpout.geometry);
                
                var returnMesh = OpenPlus.combineMesh( [this.outerSpout.geometry,
                    this.innerSpout.geometry, this.outerVessel.geometry,
                    this.innerVesselMesh.geometry, this.vesselToHandleMesh.geometry,
                    this.handleTensionerMesh.geometry, this.bottomTensioner.geometry,
                    this.handleMesh.geometry],[] );
                    
                console.log(returnMesh);
                    
                return makeSTLBlob(returnMesh);
            };
            
            Jug.prototype.TransOuterSpoutVars = function(transZ) {
                
                this.outerSpoutVars.innerSpoutTipPt[2] = 
                        this.outerSpoutVars.innerSpoutTipPt[2] + transZ;
                this.outerSpoutVars.innerTopIntCircLinePt[2] = 
                        this.outerSpoutVars.innerTopIntCircLinePt[2] + transZ;
                
                var transMat = OpenPlus.MatrixTranslation([0,0,transZ]);
                
                this.outerSpoutVars.innerClosingArc = this.outerSpoutVars.innerClosingArc.transform(transMat);
                this.outerSpoutVars.innerSpoutCrv = this.outerSpoutVars.innerSpoutCrv.transform(transMat);
                
            }

            Jug.prototype.setSpoutHeight = function (point) {
                this.spoutHeight = this.connectorHeight - point[2];

                removeFromScene(this.outerSpout);
                removeFromScene(this.innerSpout);
                removeFromScene(this.outerVessel);
                
                this.BuildOuterSpout();
                this.BuildInnerSpout();
                this.BuildOuterVessel();
                
                scene.add(this.outerSpout);
                scene.add(this.innerSpout);
                scene.add(this.outerVessel);
            };

            Jug.prototype.setSpoutLength = function (point) {
                this.spoutLength = point[0] - (this.vesselDiameter / 2) - this.margin - this.offset;

                removeFromScene(this.outerSpout);
                removeFromScene(this.innerSpout);
                
                this.BuildOuterSpout();
                this.BuildInnerSpout();
                
                scene.add(this.outerSpout);
                scene.add(this.innerSpout);
            };


            Jug.prototype.setConnectorHeight = function (point) {

                var translateZ = point[2] - this.connectorHeight;

                this.connectorHeight = point[2];
                
                var aboveConnectorHeight = 
                        (this.connectorHeight - this.maxInnerSpoutHeight) > (this.rimHeight + this.spoutMargin);


                if (this.spoutHeight > this.connectorHeight) {
                    this.spoutHeight = this.connectorHeight - this.margin;
                    
                    removeFromScene(this.outerSpout);
                    this.BuildOuterSpout();
                    scene.add(this.outerSpout);
                } else {
                    this.outerSpout.translateZ(translateZ);
                    this.TransOuterSpoutVars(translateZ);
                }
                
                if ( !aboveConnectorHeight || aboveConnectorHeight !== this.fullInnerHeight) {
                    
                    removeFromScene(this.innerSpout);
                    this.BuildInnerSpout();
                    scene.add(this.innerSpout);
                } else {
                    this.innerSpout.translateZ(translateZ);
                }
                

                removeFromScene(this.innerVesselMesh);
                removeFromScene(this.vesselToHandleMesh);
                removeFromScene(this.outerVessel);

                this.BuildInnerVessel();
                this.BuildVesselHandle();
                this.BuildOuterVessel();

                scene.add(this.innerVesselMesh);
                scene.add(this.vesselToHandleMesh);
                scene.add(this.outerVessel);

                this.handleTensionerMesh.translateZ(translateZ);
                this.handleMesh.translateZ(translateZ);
                handle.translateZ(translateZ);

                var outerRadius = (this.vesselDiameter / 2) + this.margin + this.offset;

                this.spoutLengthHandler.updateHandler(
                        [outerRadius + this.spoutLength, 0, this.connectorHeight],
                        {origin: [outerRadius, 0, this.connectorHeight],
                            direction: [10, 0, 0]}
                );
                this.spoutHeightHandler.updateHandler(
                        [outerRadius, 0, this.connectorHeight - this.spoutHeight],
                        {origin: [outerRadius, 0, this.margin],
                            direction: [0, 0, this.connectorHeight - this.margin]}
                );

                var outerHandleRadius = (this.handleDiameter / 2) + this.margin + this.offset;

                this.handleHandler.updateHandler(
                        [-(outerRadius + outerHandleRadius + this.handleLength), 0, this.connectorHeight],
                        {origin: [-(outerRadius + this.tensionerHeight + outerHandleRadius), 0, this.connectorHeight],
                            direction: [-20, 0, 0]}
                );

            };

            Jug.prototype.setHandleLength = function (point) {

                var outerRadius = (this.vesselDiameter / 2) + this.margin + this.offset;
                var outerHandleRadius = (this.handleDiameter / 2) + this.margin + this.offset;

                var translateX = -point[0] - (outerRadius + outerHandleRadius + this.handleLength);

                this.handleLength = -point[0] - (outerRadius + outerHandleRadius);

                removeFromScene(this.handleMesh);
                this.BuildHandleBridge();
                scene.add(this.handleMesh);

                this.handleTensionerMesh.translateX(-translateX);
                handle.translateX(-translateX);
            };

            var jug = new Jug();

            var loader = new THREE.STLLoader();

            var glassMaterial = new THREE.MeshPhongMaterial({
                color: 0x8b9dc3,
                specular: 0x111111,
                shininess: 200,
                transparent: true,
                opacity: 0.1,
                shading: THREE.SmoothShading,
                depthWrite: false
            });

            var bronzeMaterial = new THREE.MeshPhongMaterial({
                color: 0x150505,
                specular: 0xee6600,
                shininess: 10,
                //envMap: textureCube,
                combine: THREE.MixOperation,
                reflectivity: 0.25
            });

            var goldMaterial = new THREE.MeshPhongMaterial({
                color: 0xaa9944,
                specular: 0xbbaa99,
                shininess: 50,
                //envMap: textureCube,
                combine: THREE.MultiplyOperation
            });



            loader.load('vases/SINNERLIG_POT.stl', function (geometry) {
                var mesh = new THREE.Mesh(geometry, glassMaterial);

                mesh.position.set(0, 0, -18.6);

                mesh.castShadow = true;
                mesh.receiveShadow = true;

                scene.add(mesh);

            });

            var handle;

            loader.load('handles/testHandle.stl', function (geometry) {
                handle = new THREE.Mesh(geometry, goldMaterial);

                var locationX = (jug.vesselDiameter / 2) + (jug.offset * 2) +
                        (jug.margin * 2) + jug.handleLength + (jug.handleDiameter / 2);

                var locationZ = 15 - jug.connectorHeight;

                handle.position.set(-locationX, 0, -locationZ);

                handle.castShadow = true;
                handle.receiveShadow = true;

                scene.add(handle);

            });
            
            exportJug = function() {
                var saveFile = jug.makeSTL();
                
                saveAs(saveFile, "JUG_CONNECTOR.stl");
            };

            threeRender();

        </script>

    </body>

</html>