<!DOCTYPE html>
<html>

    <head>
        <script src="../lib/OpenPlus.js"></script>
        <script src="../lib/verb.js"></script>
        <script src="../lib/three.min.js"></script>
        <script src="../lib/verbToThreeConversion.js"></script>
        <script src="../lib/OrbitControls.js"></script>
        <script src="../lib/threeBasic.js"></script>
        <script src="../lib/STLLoader.js"></script>

        <style type="text/css">
            body { 
                margin: 0; 
                background: white;

                text-align: center;
            }

            .centerDiv {

                position: absolute;
                left: 50%;
                top: 5%;

                text-align: left;
            }

            .titleContainer {
                font-family:"Tahoma";
                font-weight: bold;

                position: relative;
                left: -50%;

                z-index: -1;
            }

            #objectContainer {
            }

            .mainTitle {
                font-size: 1000%;
            }

            .product {
                font-size: 300%;
            }

            .part {
                font-size: 150%;

                text-align: left;
            }
        </style>
    </head>
    <body>

        <div id="objectContainer">
        </div>

        <div class="centerDiv">
            <div class="titleContainer">
                <span class="mainTitle">PS</span><span class="mainTitle">/</span><span class="product">Cupboard</span><br>
                <span class="part">LEG</span><span class="part"> + </span><span class="part">WALL</span><span class="part"> + </span><span class="part">SHELF</span>
            </div>
        </div>

        <script>


            threeSetup();
            
            ThinNut = function (mSize) {
                this.m = mSize;
                
                this.height = 0.5 * mSize;
                this.width = 1.8 * mSize;
                this.diameter = 2 * mSize;
            };

            Leg = function (diameter, height) {
                this.diameter = diameter;
                this.height = height;
                this.mesh;
                
                this.materialFront = new THREE.MeshLambertMaterial({
                    color: 0xffff99
                    , side: THREE.FrontSide
                    , shading: THREE.SmoothShading
                });

                this.materialBack = new THREE.MeshLambertMaterial({
                    color: 0xffff99
                    , side: THREE.BackSide
                    , shading: THREE.SmoothShading
                });

                this.build();
            };

            Leg.prototype.build = function () {
                var radius = this.diameter / 2;
                var height = this.height;

                var center = [0, 0, 0];
                var xAxis = [1, 0, 0];
                var yAxis = [0, 1, 0];
                var zAxis = [0, 0, 1];

                //create the bottom cap circle of the cylinder
                var circle = new verb.geom.Circle(
                        center, xAxis, yAxis, radius);

                var circleGeom = OpenPlus.PlanarSrf([circle]);
                var bottomCircleMesh = new THREE.Mesh(circleGeom);

                //clone and translate circle to create top cap
                var topCircleMesh = bottomCircleMesh.clone();
                topCircleMesh.translateZ(height);

                //cylinderMesh, is a open cylinder shape
                var cylinderNurb = new verb.geom.CylindricalSurface(
                        zAxis, xAxis, center, height, radius);

                var cylinderMesh = new THREE.Mesh(cylinderNurb.toThreeGeometry());
                
                //add meshes to array to combine into one mesh
                var frontMeshes = [topCircleMesh];
                var backMeshes = [bottomCircleMesh, cylinderMesh];
                
                //combine the cylinder and the bottom and top meshes
                this.mesh = OpenPlus.combineMesh(frontMeshes, backMeshes,
                    this.materialFront, this.materialBack);

            };

            ConnectorLegWallShelf = function (leg, wallRib, nut) {
                //margin and offset
                this.margin = 0.3;
                this.offset = 2;
                
                //depended on connected objects
                this.radius = (leg.diameter) / 2 + this.margin;
                
                this.x = wallRib.x + (this.margin * 2);
                this.y = wallRib.y + (this.margin * 2);
                
                //dependend on the diameter of the nut
                this.nutM = nut.m;
                this.nutHeight = nut.height + this.margin;
                this.nutWidth = nut.width;
                this.nutRadius = (nut.diameter / 2) + this.margin;
                
                this.materialFront = new THREE.MeshLambertMaterial({
                    color: 0x99ff66
                    , side: THREE.FrontSide
                    , shading: THREE.SmoothShading
                });

                this.materialBack = new THREE.MeshLambertMaterial({
                    color: 0x99ff66
                    , side: THREE.BackSide
                    , shading: THREE.SmoothShading
                });
                
                this.mesh;
                
                this.build();
            };
            
            ConnectorLegWallShelf.prototype.build = function (){
                var center = [0,0,0];
                var xAxis = [1,0,0];
                var yAxis = [0,1,0];
                var zAxis = [0,0,1];
                
                var pointA = [0, this.nutRadius, 0];
                var pointB = [this.radius + this.nutHeight, this.nutRadius / 2, 0];
                var circle = {center: center, radius: this.radius};
                
                var intPoint =
                    OpenPlus.CircleLineIntersect(pointA, pointB, circle)[1];
                intPoint[2] = 0;
                
                var angle = OpenPlus.AnglePtOnCircle(intPoint, this.radius);
                
                var innerArc = new verb.geom.Arc(center, xAxis, yAxis,
                    this.radius, angle, (Math.PI * 2) - angle);
                
                var nutSlotLine = new verb.geom.Line(intPoint, pointB);
                
                var matMirror = [[1,0,0], [0,-1,0], [0,0,1]];
                var nutSlotLineMir = nutSlotLine.transform(matMirror);;
                
                var closingNutLine = new verb.geom.Line(
                        nutSlotLine.point(1), nutSlotLineMir.point(1));
                
                //create the rectangles for wallholders
                center = [1,-1,0];
                center = verb.core.Vec.normalized(center);
                center = verb.core.Vec.mul(
                        (this.radius + this.offset + (this.x/2)), center);
                xAxis = [1,-1,0];
                yAxis = [1,1,0];
                
                //var innerRectangle
                var rectA = OpenPlus.Rectangle( center,
                    xAxis, yAxis, this.x, this.y);
                
                //mirror of innerRectangle
                var quat = OpenPlus.QuatFromAxisAngle(zAxis, Math.PI/2);
                var matRotate = OpenPlus.MatrixFromQuat(quat);
                
                var rectB = rectA.transform(matRotate);
                
                //create offsetLine
                var transAxisA = verb.core.Vec.normalized(xAxis);
                var transAxisAScaled = 
                    verb.core.Vec.mul(this.x/2 + this.offset, transAxisA);
                var transAxisB = verb.core.Vec.normalized(yAxis);
                var transAxisBScaled = 
                    verb.core.Vec.mul(this.y/2 + this.offset, transAxisB);
                
                var transVec = verb.core.Vec.add(transAxisAScaled, transAxisBScaled);
                
                var p1 = verb.core.Vec.add(center, transVec);
                var p2 = [p1[0],-p1[1],p1[2]];
                
                var offsetLine1 = new verb.geom.Line(p1, p2);
                
                transAxisBScaled = 
                    verb.core.Vec.mul(this.x + (this.offset * 2), transAxisB);
                
                var  p3 = verb.core.Vec.sub(p1, transAxisBScaled);
                var  p4 = [p3[0],-p3[1],p3[2]];
                
                var offsetLine2 = new verb.geom.Line(p1, p3);
                var offsetLine3 = new verb.geom.Line(p2, p4);
                
                center = [0,0,0];
                
                //create intersection for outerArc
                circle = {center: center, radius: this.radius + this.offset};
                pointB = verb.core.Vec.add(p3, transAxisAScaled);
                
                var p5 = OpenPlus.CircleLineIntersect(p3,pointB,circle)[1];
                p5[2] = 0;
                var p6 = [p5[0],-p5[1],p5[2]];
                
                var offsetLine4 = new verb.geom.Line(p3, p5);
                var offsetLine5 = new verb.geom.Line(p4, p6);
                
                angle = OpenPlus.AnglePtOnCircle( p6, this.radius + this.offset);
                
                var xAxis = [1,0,0];
                var yAxis = [0,1,0];
                
                var outerArc = new verb.geom.Arc(center, xAxis, yAxis,
                    this.radius + this.offset, angle, (Math.PI * 2) - angle);
                
                var lines = [offsetLine1.reverse(), offsetLine2, offsetLine3, offsetLine4,
                    offsetLine5, outerArc, rectA.reverse(), rectB.reverse(), innerArc,
                    nutSlotLine, nutSlotLineMir, closingNutLine];
                
                var bottomGeom = OpenPlus.PlanarSrf(lines)[0];
                var bottomMesh = new THREE.Mesh(bottomGeom);
                
                var extrusion = this.nutWidth;
                var extrVec = [0, 0, extrusion];
                
                var topMesh = bottomMesh.clone();
                topMesh.translateZ(extrusion);
                
                //create the entrance of the screw in the connector
                //create rectangle and circle
                
                var xAxis = verb.core.Vec.sub(p1, p2);
                var yAxis = [xAxis[1], xAxis[0], 0];
                yAxis = verb.core.Vec.normalized(yAxis);
                yAxis = verb.core.Vec.mul((-this.nutWidth / 2), yAxis);
                
                var centerPoint = verb.core.Vec.add(p1, p2);
                centerPoint = verb.core.Vec.div(centerPoint, 2);
                
                var center = verb.core.Vec.add(centerPoint, yAxis);
                
                var rectFront = OpenPlus.Rectangle(center,
                    xAxis, yAxis, offsetLine1.length(), this.nutWidth);
                
                var screwEntrance = new verb.geom.Circle(center, xAxis,yAxis,
                    (this.nutM / 2) + this.margin);
                    
                var front = OpenPlus.PlanarSrf([rectFront, screwEntrance])[0];
                
                var rotMat = OpenPlus.MatrixRotationOverLine(p1, p2, Math.PI*1.5);
                var mat = OpenPlus.ToThreeMatrix(rotMat);
                
                front.applyMatrix(mat);
                
                var frontMesh = new THREE.Mesh(front);
                
                //then create the exit
                center = [this.radius + this.nutHeight, 0, this.nutWidth / 2];
                var gapHole = OpenPlus.Polygon(center, xAxis, yAxis, 6, this.nutRadius);
                
                var screwExit = new verb.geom.Circle(center, xAxis,yAxis,
                    (this.nutM / 2) + this.margin);
                    
                var nutCap = OpenPlus.PlanarSrf([gapHole.reverse(), screwExit])[0];
                
                rotMat = OpenPlus.MatrixRotationOverLine(center, verb.core.Vec.add(center, xAxis), Math.PI /2);
                mat = OpenPlus.ToThreeMatrix(rotMat);
                
                var tempLine = new verb.geom.Line(center, verb.core.Vec.add(center, xAxis));
                
                nutCap.applyMatrix(mat);
                
                var nutCapMesh = new THREE.Mesh(nutCap);
                
                //extract all lines for final mesh
                var outerArcExtr = new THREE.Mesh(
                        new verb.geom.ExtrudedSurface(outerArc, extrVec).toThreeGeometry());
                var rectHoleA = new THREE.Mesh(
                        new verb.geom.ExtrudedSurface(rectA, extrVec).toThreeGeometry());
                var rectHoleB = new THREE.Mesh(
                        new verb.geom.ExtrudedSurface(rectB, extrVec).toThreeGeometry());
                
                var extrLine2 = new THREE.Mesh(
                        new verb.geom.ExtrudedSurface(offsetLine2, extrVec).toThreeGeometry());
                var extrLine3 = new THREE.Mesh(
                        new verb.geom.ExtrudedSurface(offsetLine3, extrVec).toThreeGeometry());
                var extrLine4 = new THREE.Mesh(
                        new verb.geom.ExtrudedSurface(offsetLine4, extrVec).toThreeGeometry());
                var extrLine5 = new THREE.Mesh(
                        new verb.geom.ExtrudedSurface(offsetLine5, extrVec).toThreeGeometry());
                
                var backMeshes = [bottomMesh, outerArcExtr, rectHoleA, rectHoleB,
                    extrLine3, extrLine5, frontMesh];
                var frontMeshes = [topMesh, extrLine2, extrLine4, nutCapMesh];
                
                //combine the cylinder and the bottom and top meshes
                this.mesh = OpenPlus.combineMesh(frontMeshes, backMeshes,
                    this.materialFront, this.materialBack);
            };

            CupBoard = function () {
                //overal variables
                this.height;
                this.width;
                this.length;

                //bought variables
                this.legDiameter;
                this.shelfThickness;
                this.wallThickness;

                //printed variables
                this.connectorLegWallShelf;
                this.connectorLegShelf;
                this.connectorLegShelfWall;

                //build the cupboard;
                this.Build();
            };

            CupBoard.prototype.Build = function () {
                
                var nut  = new ThinNut(3);
                var leg = new Leg(22, 200);
                
                //this is a temporary object that needs its own function
                var wallRib = {x: 9, y:9};
                
                var d1 = Date.now();
                var connectorLegWallShelf = new ConnectorLegWallShelf(
                    leg, wallRib, nut);
                var d2 = Date.now();
                console.log("built connector in ", (d2 - d1), " ms ");
                
                //scene.add(leg.mesh);
                scene.add(connectorLegWallShelf.mesh);

            };
            
            var cupboard = new CupBoard();

            threeRender();



        </script>

    </body>

</html>