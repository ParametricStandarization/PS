<!DOCTYPE html>
<html>

    <head>
        <script src="../lib/verb.js"></script>
        <script src="../lib/three.min.js"></script>
        <script src="../lib/verbToThreeConversion.js"></script>
        <script src="../lib/OrbitControls.js"></script>
        <script src="../lib/threeBasic.js"></script>
        <script src="../lib/STLLoader.js"></script>

        <style type="text/css">
            body { 
                margin: 0; 
                background: white;

                text-align: center;
            }

            .centerDiv {

                position: absolute;
                left: 50%;
                top: 5%;

                text-align: left;
            }

            .titleContainer {
                font-family:"Tahoma";
                font-weight: bold;

                position: relative;
                left: -50%;

                z-index: -1;
            }

            #objectContainer {
            }

            .mainTitle {
                font-size: 1000%;
            }

            .product {
                font-size: 300%;
            }

            .part {
                font-size: 150%;

                text-align: left;
            }
        </style>
    </head>
    <body>

        <div id="objectContainer">
        </div>

        <div class="centerDiv">
            <div class="titleContainer">
                <span class="mainTitle">PS</span><span class="mainTitle">/</span><span class="product">Cupboard</span><br>
                <span class="part">LEG</span><span class="part"> + </span><span class="part">WALL</span><span class="part"> + </span><span class="part">SHELF</span>
            </div>
        </div>

        <script>


            threeSetup();

            Leg = function (diameter, height) {
                this.diameter = diameter;
                this.height = height;
                this.mesh;
                
                this.materialFront = new THREE.MeshLambertMaterial({
                    color: 0xffff99
                    , side: THREE.FrontSide
                    , shading: THREE.SmoothShading
                });

                this.materialBack = new THREE.MeshLambertMaterial({
                    color: 0xffff99
                    , side: THREE.BackSide
                    , shading: THREE.SmoothShading
                });

                this.build();
            };

            Leg.prototype.build = function () {
                var radius = this.diameter / 2;
                var height = this.height;

                var center = [0, 0, 0];
                var xAxis = [1, 0, 0];
                var yAxis = [0, 1, 0];
                var zAxis = [0, 0, 1];

                //create the bottom cap circle of the cylinder
                var circle = new verb.geom.Circle(
                        center, xAxis, yAxis, radius);

                var circleGeom = OpenPlus.PlanarSrf([circle]);
                var bottomCircleMesh = new THREE.Mesh(circleGeom);

                //clone and translate circle to create top cap
                var topCircleMesh = bottomCircleMesh.clone();
                topCircleMesh.translateZ(height);

                //cylinderMesh, is a open cylinder shape
                var cylinderNurb = new verb.geom.CylindricalSurface(
                        zAxis, xAxis, center, height, radius);

                var cylinderMesh = new THREE.Mesh(cylinderNurb.toThreeGeometry());
                
                //add meshes to array to combine into one mesh
                var frontMeshes = [topCircleMesh];
                var backMeshes = [bottomCircleMesh, cylinderMesh];
                
                console.log(frontMeshes);
                console.log(backMeshes);
                
                //combine the cylinder and the bottom and top meshes
                this.mesh = OpenPlus.combineMesh(frontMeshes, backMeshes,
                    this.materialFront, this.materialBack);

            };

            CupBoard = function () {
                //overal variables
                this.height;
                this.width;
                this.length;

                //bought variables
                this.legDiameter;
                this.shelfThickness;
                this.wallThickness;

                //printed variables
                this.connectorLegWallTop;
                this.connectorLegWallBottom;
                this.connectorLegShelf;
                this.connectorLegShelfWall;

                //build the cupboard;
                this.Build();
            };

            CupBoard.prototype.Build = function () {
                var leg = new Leg(20, 200);

                scene.add(leg.mesh);

            };

            OpenPlus = {
                EqualPoints: function (pointA, pointB) {
                    if (Math.abs(pointA[0] - pointB[0]) > 1e-6)
                        return false;
                    if (Math.abs(pointA[1] - pointB[1]) > 1e-6)
                        return false;
                    if (Math.abs(pointA[2] - pointB[2]) > 1e-6)
                        return false;
                    return true;
                },
                JoinCurves: function (tempCurves) {
                    var curves = tempCurves.slice(0);

                    var CurveLine = function (curve) {
                        this.start = curve.point(0);
                        this.end = curve.point(1);
                        this.curves = [curve];
                        this.closed = OpenPlus.EqualPoints(this.start, this.end);
                    };

                    CurveLine.prototype.push = function (newCurve) {
                        this.end = newCurve.point(1);
                        this.curves.push(newCurve);
                        this.closed = OpenPlus.EqualPoints(this.start, this.end);
                    };

                    CurveLine.prototype.unshift = function (newCurve) {
                        this.start = newCurve.point(0);
                        this.curves.unshift(newCurve);
                        this.closed = OpenPlus.EqualPoints(this.start, this.end);
                    };

                    var curveLine = new CurveLine(curves.splice(0, 1)[0]);
                    var connectedCurves = [curveLine];

                    //sure this algorithm is horrible, but should work for now
                    if (curves.length !== 0) {

                        for (var i = 0; i < connectedCurves.length; i++) {

                            var tempLine = connectedCurves[i];

                            if (!tempLine.closed) {

                                for (var j = 0; j < curves.length; j++) {

                                    var curve = curves[j];

                                    var curveStart = curve.point(0);
                                    var curveEnd = curve.point(1);

                                    if (OpenPlus.EqualPoints(curveStart, tempLine.end)) {
                                        tempLine.push(curve);
                                    } else if (OpenPlus.EqualPoints(curveEnd, tempLine.start)) {
                                        tempLine.unshift(curve);
                                    } else if (OpenPlus.EqualPoints(curveStart, tempLine.start)) {
                                        tempLine.unshift(curve.reverse());
                                    } else if (OpenPlus.EqualPoints(curveEnd, tempLine.end)) {
                                        tempLine.push(curve.reverse());
                                    } else {
                                        continue;
                                    }

                                    curves.splice(j, 1);
                                    j = -1;

                                    if (tempLine.closed)
                                        break;
                                }
                            }

                            if (curves.length === 0)
                                break;
                            else
                                connectedCurves.push(new CurveLine(curves.splice(0, 1)[0]));

                        }
                    }

                    var returnArray = [];
                    for (var i = 0; i < connectedCurves.length; i++) {
                        returnArray[i] = connectedCurves[i].curves;
                    }

                    return returnArray;
                },
                
                PlanarSrf: function (curves, willFlip) {
                    var flipped = willFlip || false;

                    //first need to check if all are curves

                    //create joined lines, should check if these are inside each other or not
                    //this will define if an object with or without hole will be made
                    var curveLines = OpenPlus.JoinCurves(curves);

                    //now I need to check if the curves are planar
                    //http://verbnurbs.com/docs/core/Trig/#ispointinplane
                    //http://threejs.org/docs/#Reference/Math/Plane

                    //then check if curves intersect or are inside each other
                    //those that are inside a different path need to create their own geometry

                    var path = new THREE.Path;
                    path.autoClose = false;

                    for (var i = 0; i < curveLines.length; i++) {
                        var tempCurves = curveLines[i];

                        var startPoint = tempCurves[0].point(0);
                        var vertices = [new THREE.Vector2(startPoint[0], startPoint[1])];

                        for (var j = 0; j < tempCurves.length; j++) {
                            var curve = tempCurves[j].toThreeGeometry();

                            var verticeClone = curve.vertices.slice(1);

                            vertices = vertices.concat(verticeClone);
                        }

                        path.fromPoints(vertices);
                    }

                    var shape = path.toShapes(flipped, false)[0];

                    var geometry = new THREE.ShapeGeometry(shape, {curveSegments: 100});

                    return geometry;
                },
                
                //combine meshes into a single mesh
                combineMesh: function (meshesFront, meshesBack,
                    materialFront, materialBack) {

                    var mergedGeom = new THREE.Geometry();

                    for (var i = 0; i < meshesFront.length; i++) {
                        var tempMesh = meshesFront[i];

                        tempMesh.updateMatrix();
                        mergedGeom.merge(tempMesh.geometry, tempMesh.matrix, 0);
                    }

                    for (var i = 0; i < meshesBack.length; i++) {
                        var tempMesh = meshesBack[i];

                        tempMesh.updateMatrix();
                        mergedGeom.merge(tempMesh.geometry, tempMesh.matrix, 1);
                    }

                    var materials = [materialFront, materialBack];
                    var resultMesh = new THREE.Mesh(mergedGeom, new THREE.MeshFaceMaterial(materials));

                    return resultMesh;
                },
                
                //function to mirror and combine meshes and make them into a complete mesh
                mirrorCombineMesh: function (meshesFront, meshesBack,
                    materialFront, materialBack) {
                        
                    var mS = (new THREE.Matrix4()).identity();
                    mS.elements[5] = -1;

                    var mergedGeom = new THREE.Geometry();

                    for (var i = 0; i < meshesFront.length; i++) {
                        var tempMesh = meshesFront[i];

                        tempMesh.updateMatrix();
                        mergedGeom.merge(tempMesh.geometry, tempMesh.matrix, 0);

                        var tempMeshClone = tempMesh.clone();

                        tempMeshClone.applyMatrix(mS);
                        tempMeshClone.updateMatrix();

                        mergedGeom.merge(tempMeshClone.geometry, tempMeshClone.matrix, 1);
                    }

                    for (var i = 0; i < meshesBack.length; i++) {
                        var tempMesh = meshesBack[i];

                        tempMesh.updateMatrix();
                        mergedGeom.merge(tempMesh.geometry, tempMesh.matrix, 1);

                        var tempMeshClone = tempMesh.clone();

                        tempMeshClone.applyMatrix(mS);
                        tempMeshClone.updateMatrix();

                        mergedGeom.merge(tempMeshClone.geometry, tempMeshClone.matrix, 0);
                    }

                    var materials = [materialFront, materialBack];
                    var resultMesh = new THREE.Mesh(mergedGeom, new THREE.MeshFaceMaterial(materials));

                    return resultMesh;
                }
            };

            var cupboard = new CupBoard();

            threeRender();



        </script>

    </body>

</html>